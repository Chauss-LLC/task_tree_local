"""The class representing the task."""

from itertools import tee
from typing import Iterable
import tasktree.core.connection as c
import tasktree.core.connections as cc
from tasktree.core.status import STATUS

"""System of tasks."""

import random
import string
from typing import Dict

class IdReadOnlyDescriptor:
    """Descriptor for id field, so you can not modify id of the established connection."""

    def __get__(self, obj, cls):
        """Returns the id."""
        return obj._id_field

    def __set__(self, obj, val):
        """Sets the id. Works only once for each object."""
        if hasattr(obj, '_id_set') and obj._id_set:
            raise TypeError(f"'{type(obj).__name__}' object does not support id assignment")
        obj._id_field = val
        obj._id_set = True

TaskIII = None

class TaskSystem:
    """Control the system of tasks."""

    IdType = str
    MINIMAL_TASK_ID_LENGTH = 6

    root: IdType
    tasks: Dict[IdType, TaskIII] = dict()

    def is_task_id_correct(self=None, task_id: IdType = IdType()) -> bool:
        """Check if task id is correct (allow to discard some ids)."""
        return len(task_id) >= TaskSystem.MINIMAL_TASK_ID_LENGTH

    def generate_task_id(self=None) -> IdType:
        """Generate random task id."""
        allowed_characters = list(string.ascii_lowercase + string.digits)
        return "".join(
            random.choices(allowed_characters, k=TaskSystem.MINIMAL_TASK_ID_LENGTH)
        )

    def create_task(self, *args, **kwargs) -> TaskIII:
        """Create new task and set its internal pointer to the current system.
        For arguments see Task __init__ method.
        """
        kwargs['system'] = self
        return Task(*args, **kwargs)


class Task:
    """The class representing the task."""

    """After initialization this field is read-only."""
    id: TaskSystem.IdType = IdReadOnlyDescriptor()

    system: TaskSystem
    _cncts: cc.Connections
    title: str
    status: STATUS

    def __init__(self, title: str="Task template title", system: TaskSystem = None,
                 status: STATUS = STATUS.PENDING, task_id: TaskSystem.IdType = None, 
                 parent = None, children = None):
        """Create a new Task. 

        See below for more information. Children must be Iterable type contain either Task or id.
        Note that if you use id then you must provide system object.
        System object can be obtained from parent or children Tasks.
        New system will be created only if neither parent nor children provide it and you have not specified it in parameters.
        In this case you can not use ids when passing children or parent arguments.

        Do not worry: when task is created it will contain a reference to a system.
        But you should be careful and do not pass here parent or children which have different system pointers or you will get Exception.

        :param title: The name of the task.
        :param system: The system to add the task to.
        :param status: The status of the task (default is STATUS.PENDING).
        :param id: Id of new task. By default it will be autogenerated as specialized in TaskSystem.
        :param parent: The parent task of this task.
        :type parent: Task or TaskSystem.IdType or None
        :param children: Children tasks of new task.
        :type children: Iterable[Task] or Iterable[TaskSystem.IdType] or None
        """
        self.title = title
        self.status = status
        if system is None: 
            system, children = self.__try_to_obtain_system_from_arguments(parent, children)
        else:
            children = self.__check_parent_and_children_for_same_system(system, parent, children)
        self.__initialize_system_and_id(system, task_id)
        self.__connect_parents_and_children(
            self.__convert_id_to_task(parent),
            map(lambda ch: self.__convert_id_to_task(ch), children) if children is not None else None)

    @property
    def parent(self):
        """The parent of the task (may be None if it is root node)."""
        try:
            return self.system.tasks[next(self._cncts.with_tag("parent"))._id]
        except StopIteration:
            return None

    @property
    def children(self) -> list:
        """The children of the task."""
        return list(self.system.tasks[cnct._id] for cnct in self._cncts.with_tag("child"))

    def add_child(self, *args, **kwargs):
        """Create new child of the current task. 
        For arguments see Task __init__ method."""
        kwargs["parent"] = self
        return Task(*args, **kwargs)

    def change_parent(self, parent_id: TaskSystem.IdType):
        """Change the parent by id. Disconnect if neccessary."""
        if parent_id not in self.system.tasks:
            raise ValueError("Can not change parent to the task from another system.")
        if self.parent is not None:
            del self.parent._cncts[self.id] # order is important
            del self._cncts[self.parent.id]
        self._cncts.add_connection(c.Connection(parent_id, [c.Connection.PARENT_TAG, "guard"]))
        self.system.tasks[parent_id]._cncts.add_connection(c.Connection(self.id, [c.Connection.CHILD_TAG]))

    def __convert_id_to_task(self, task_id):
        """Get the id and return the task by searching in system. If passed type was Task then return it."""
        if isinstance(task_id, Task):
            return task_id
        return self.system.tasks.get(task_id)

    def __connect_parents_and_children(self, parent, children):
        """Connects selected parents and children assuming that the system pointers are correct everywhere (and inside ourself too).
        Establish connection to self, to children and to parent. Establish connection in children and in parent.
        :type children: Iterable of Tasks or None.
        :type parent: Task or None.
        """
        self._cncts = cc.Connections(self_id=self.id)
        if parent is not None:
            self._cncts.add_connection(c.Connection(parent.id, ["parent", "guard"]))
            parent._cncts.add_connection(c.Connection(self.id, ["child"]))
        if children is not None:
            for ch in children:
                self._cncts.add_connection(c.Connection(ch.id, ["child"]))
                ch._cncts.add_connection(c.Connection(self.id, ["parent", "guard"]))

    def __initialize_system_and_id(self, system: TaskSystem, task_id: TaskSystem.IdType) -> None:
        """If system is not initialized, create a new one;
        If id is not specified, generate a new one.
        Add myself to the system.
        """
        # Set system pointer:
        was_created_system: bool = False
        if system is None:
            self.system = TaskSystem()
            was_created_system = True
        else:
            self.system = system
        # Set my id:
        if task_id is not None:
            self.id = task_id
        else:
            self.id = self.system.generate_task_id()
        # Add me to the system:
        self.system.tasks[self.id] = self
        # If I created the system then I am the root node:
        if was_created_system:
            self.system.root = self.id

    def __system_pointer_exception(self):
        raise ValueError("Passed Tasks for Task creation contain pointers to different systems, what is not supported now.")

    def __try_to_obtain_system_from_arguments(self, parent, children) -> tuple:
        """Return tuple: [0] is for the system pointer obtained from the arguments and [1] is for new children iterable.
        If arguments contain pointers to different systems, will raise an Exception.
        """
        system = None
        if parent is not None and isinstance(parent, Task):
            system = parent.system
        if children is not None:
            children, children_copy = tee(children)
            children_count = 0
            for child in children_copy:
                if child is not None:
                    children_count += 1
                    if isinstance(child, Task):
                        # If the system already exists, we compare system pointers.
                        if system is not None and system != child.system:
                            self.__system_pointer_exception()
                        else:
                            system = child.system
        if system is None and (children is not None and (children_count > 0) or parent is not None):
            raise ValueError("You have passed only ids for Task creation but forgot to pass system pointer.")
        return (system, children)

    def __check_parent_and_children_for_same_system(self, system: TaskSystem, parent, children) -> Iterable:
        """With passed system pointer this function checks arguments for same pointer.
        If we found a different system, then raises a ValueError.
        Return new pointer to the children iterable.
        """
        if parent is not None and isinstance(parent, Task) and parent.system != system:
            self.__system_pointer_exception()
        if children is not None:
            children, children_copy = tee(children)
            for child in children_copy:
                if child is not None and isinstance(child, Task) and system != child.system:
                    self.__system_pointer_exception()
        return children


TaskIII = Task
