## Особенности реализации или *на какие задачи можно разбить проект*

<ins>Мы позаботимся об архитектуре заранее</ins>, чтобы в будущем добавление новых фичей не подразумевало редактирование имеющегося кода. 

Структура проекта *может быть* такая:

1. Модуль *core*. Отвечает за непосредственное редактирование дерева.
	* Необходимо предусмотреть следующий функционал:
	* Вершины дерева - они же задачи, могут иметь статус `SOLVED`, `FAILED`, или `PENDING`. Состояние по умолчанию - `PENDING`. 
	* К вершинам дерева можно добавлять другие вершины, следует предусмотреть различные связи между вершинами, среди которых обязательно должны быть следующие:
		* Если все поддеревья решены с успехом, то корень-вершина автоматически помечается как завершенная с успехом.
		* Если корень отмечен завершенным с успехом, то все его вершины автоматически помечаются завершенными с успехом.
	* (*детали реализации*) Возможно, стоит реализовать события, описанные выше, именно как события:
		* То есть, у нас имеется сущность - вершина, которая подписывается на события дочерних вершин.
		* Первоначальными событиями являются проставление `SOLVED`, `FAILED` флагов.
		* Родительская вершина обрабатывает события дочерних вершин и автоматически выполняет какие-то действия.
		* (*почему это может быть полезно*) Представим ситуацию, когда вы создали задачу и по ее успешном завершении вам надо принять какие-то действия, например, после редактирования каталога надо сделать `commit`. Вы можете воспользоваться нашим продуктом для автоматизации этой задачи. Для этого в систему добавляется условный `listener`, срабатывающий тогда, когда вершину, к которой он прикреплён, пометили как `SOLVED`. Чтобы указать системе, что конкретно надо сделать, можно использовать bash-скрипт или питон. Да, этот аспект нашего продукта может быть не реализован в рамках семестрового проекта, однако, учитывая все факты, стоит уже на этом этапе задуматься о том, какой функционал может иметь в себе наш продукт. Иными словами, <ins>мы заботимся о деталях реализации заранее</ins>, чтобы добавление новых фичей или возможностей было максимально просто и удобно в будущем.
2. Модуль *save/load*. Отвечает за сохранения дерева внутри локальной машины.
	* Это может быть БД, это может быть просто текстовый или бинарный файл.
	* Однако, если вынести этот функционал в отдельный модуль, в будущем можно добавить другую реализацию этого же API: например, обращение к серверу и сохранение деревьев на удаленной машине.
3. Модуль *cli*. Он же command line interface.
	* Обязательная часть нашего продукта, потому что именно она является посредником между конечным пользователем и core модулем.
	* Здесь пользователю надо отобразить список сохранённых поддеревьев, отобразить сами деревья, в удобном виде предоставить способы взаимодействия с модулем *core*.
	* Опять же, вынося это в отдельный модуль, мы делаем возможным использование вместо cli какого-нибудь GUI или фронтенда. 
4. Модуль *экспорта/импорта дерева в файл*. 
	* В пункте 2 речь шла о сохранении, здесь речь идет о удобном представлении дерева в текстовом виде. 
	* Зачем это надо? Чтобы пользователь мог вместо cli выполнить экспорт в файл, затем выполнить редактирование этого файла в удобном ему редакторе, затем выполнить импорт файла.
	* Теперь редактирование возможно не только при помощи cli, но и при помощи собственного текстового редактора.
