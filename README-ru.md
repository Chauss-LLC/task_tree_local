# task_tree_local

<img src="logo_task_tree.png" alt="Логотип проекта" width="200"/>

Это локальная часть большого проекта `task_tree`.

## Постановка задачи

Многие люди нуждаются в каком-то структурированном способе фиксировать свои задачи.
Некоторые пользуются ручными дневниками, кто-то - календарем, а кто-то предпочитает хранить свои задачи в текстовом файле в папке с документами или на рабочем столе.
Во всех этих подходах есть свои плюсы и минусы. Существует не бесконечное, но достаточно большое кол-во утилит, которые позволяют организовывать свои задачи,
устанавливать дедлайны, прикреплять файлы, делиться списком задач и т.д. Большинство из них, так или иначе, будут платными.

Мы предлагаем новый продукт - task_tree, который, по сути, работает как простенькая иерархическая база данных. От корня дерева идут ветви к другим поддеревьям, 
что позволяет наглядно представлять себе задачу и ее внутреннюю структуру. Это может быть полезно любым людям, которые нуждаются в способе фиксировать свои планы.

Чтобы не быть голословными, рекомендуем обратиться к этому источнику, где вы на практике можете ощутить все положительные стороны такого подхода:

https://www.mindmeister.com/

## Базовая функциональность

Данная часть большого проекта носит лаконичное название `task_tree_local` и предоставляет все удобства для локального использования.

Реализовав основной функционал, мы можем сосредоточиться на добавлении дополнительных возможностей, реализации собственного веб-сервиса, подобного `mindmeister` и др.

Возможно, приложение будет разбито на несколько модулей, но целевой функционал должен быть следующим:

- Возможность создавать, модифицировать, редактировать и удалять поддеревья на локальной машине. 
	- Сохранение и удаление файлов с поддеревьями.
	- Реализация простого command-line интерфейса, в котором целевой пользователь может:
		* Просматривать сохраненные поддеревья.
		* Добавлять к поддеревьям новые ветви или вершины.
		* Отмечать определенные задачи как выполненные или не выполненные.
	- Экспорт дерева в текстовый файл, импорт из текстового файла.
		* Файл должен быть человекочитаемый, чтобы пользователь мог изменить его при помощи текстового редактора, а затем выполнить импорт.

## Предполагаемые инструменты решения

* Python модули:
	* `json`;
	* `psycopg2`, `psycopg2-binary` or `sqlite3` (в зависимости от того, какую БД мы выберем);
	* `cmd`, `shlex`, `argparse`, `Colorama` (для cli);
	* `rich` (для вывода дерева в терминал).

## Предполагаемый cli

Режим работы возможен через непосредственное обращение к модулю: 
```
python -m task_tree <command>           # Общая схема взаимодействия с проектом.
python -m task_tree show tree Homework  # Пример.
```
Предоставляемый набор команд:
```
# Для работы с деревьями:
list                            # Вывод идентификаторов всех сохраненных деревьев.
show   tree <TREE-ID>           # Вывод конкретного дерева.
add    tree <TREE-ID>           # Создание дерева задач.
delete tree <TREE-ID>           # Удаление дерева.
export tree <TREE-ID>           # Вывод дерева в текстовом виде.
import tree <TREE-ID>           # Импорт дерева из файла.
check  tree <TREE-ID>           # Проверка того, что все задачи в дереве решены.
# Для работы с конкретным деревом:
show   task <TASK-ID> tree <TREE-ID>          # Показать статус и другие данные о конкретной задаче в указанном дереве.
mark   task <TASK-ID> <STATUS> tree <TREE-ID> # Установка статуса на конкретную задачу в указанном дереве. 
add    task <TASK-ID> tree <TREE-ID>
delete task <TASK-ID> tree <TREE-ID>
# Для вызова cli:
cli
```
Если пользователь хочет command-line интерфейс, то мы его ему предоставим. Команды будут теми же, но для удобства мы предоставим возможность выбирать дерево для работы,
теперь пользователю не надо будет каждый раз вбивать `tree <TREE-ID>`.

Текст, который можно локализовать - это дополнительные сообщения или тексты ошибок, которые мы будем печатать пользователю при обращении к модулю.

## Рабочий процесс пользователя

* Когда пользователь садится за свой ноутбук, он загружает ОС. 
* Пока ОС загружается, пользователь продумывает задачи, которые он должен выполнить за данный сеанс работы с компьютером.
* Пользователь открывает наш продукт - запускает нужный модуль через терминал. 
* Последовательностью команд пользователь создает дерево задач. У каждой задачи есть 3 состояния:
	* Необходимо выполнить. (состояние по умолчанию)
	* Завершено с успехом. 
	* Завершено с провалом.
* У задач есть задачи-родители и задачи-потомки. Наш проект обязательно предлагает следующий функционал относительно автоматизации:
	* Если пользователь отметил задачу решенной, то все ее задачи-потомки автоматически обозначаются решенными.
	* Если пользователь отметил задачу решенной с провалом, то ее родитель отмечается решенным с провалом.
* Далее пользователь начинает выполнять задачи, по мере их решения он возвращается к нашему модулю, чтобы пометить нужную задачу завершенной с успехом или провалом.
* В конце сеанса работы пользователь проверяет дерево задач (`check tree`) на тот факт, что оно полностью выполнено с успехом.
* Если не все задачи выполнены, пользователь сохраняет дерево для следующего сеанса работы.
	* В отличие от блокнота, в котором пользователю, может быть, и будет удобней работать, наш продукт сохраняет файл в каталог по умолчанию.
	* Таким образом пользователю не надо задумываться о том, где хранятся деревья.
* Завершение работы.

## Перспективы данного направления

* От фронтенда до REST API.
* От телеграммного бота до приложений на android.
* От прикрепления фотографий до share-деревьев и прикрепления любых файлов или заметок. 
* Комментирование.
* От автоматических событий до собственного языка управления сценариями.
* От импорта github issue до экспорта в google calendar.
* Обратите внимание, что модуль может стать полноценным питоньим модулем и залететь на `pypi`!
* Сериализация и десериализация. Экспорт дерева в картинку. GUI.
* В случае сервера можно выполнять выборочный share: делиться не деревом, а конкретными вершинами.
* Добавление делайнов к вершинам. Вывод не в виде дерева, а в виде расписания. 
* Напоминания и уведомления.
* Статистика (отображение состояния выполненной задачи в процентах).
* Метки или тэги, по которым удобно было бы быстро перемещаться по дереву.
* Можно указывать стоимость каждой вершины и автоматически считать стоимость всех запланированных дел.
* и тд.

Это список возможных направлений разработки. Очевидно, что это не уместится в семестровый проект, однако само наличие такого спектра возможностей и направлений развития лишь подтверждает наш выбор в сторону именно `task_tree`.